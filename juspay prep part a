import java.io.*;
import java.util.*;
import java.util.ArrayDeque;

class Node {
    String name;
    Node parent;
    List<Node> children;
    int lockedBy; // -1 if not locked
    int lockedDescendantCount;
    Set<Node> lockedDescendants;
    
    Node(String name, int childCapacity) {
        this.name = name;

        this.children = new ArrayList<>();
        this.lockedBy = -1;

        this.children = new ArrayList<>(childCapacity);
        this.lockedBy = null;

        this.lockedDescendantCount = 0;
        this.lockedDescendants = new HashSet<>();
    }
}

public class LockingTree {
    private final Map<String, Node> nodeMap = new HashMap<>();
    
    public LockingTree(int n, int m, List<String> nodeNames) {
        for (String name : nodeNames) {
            nodeMap.put(name, new Node(name, m));
        }
        
        Node root = nodeMap.get(nodeNames.get(0));
        Queue<Node> queue = new ArrayDeque<>();
        queue.offer(root);
        
        int index = 1;
        while (!queue.isEmpty() && index < n) {
            Node current = queue.poll();
            for (int i = 0; i < m && index < n; i++) {
                Node child = nodeMap.get(nodeNames.get(index++));
                child.parent = current;
                current.children.add(child);
                queue.offer(child);
            }
        }
    }
    
    public boolean lock(String name, int uid) {
        Node node = nodeMap.get(name);
        if (node.lockedBy != -1 || node.lockedDescendantCount > 0)
            return false;
        
        Node ancestor = node.parent;
        while (ancestor != null) {
            if (ancestor.lockedBy != -1) return false;
            ancestor = ancestor.parent;
        }
        
        node.lockedBy = uid;
        updateAncestorDescendants(node, 1);
        return true;
    }
    
    public boolean unlock(String name, int uid) {
        Node node = nodeMap.get(name);
        if (node.lockedBy != uid) return false;

        node.lockedBy = -1;
        updateAncestorDescendants(node, -1);
        return true;
    }
    
    public boolean upgrade(String name, int uid) {
        Node node = nodeMap.get(name);
        if (node.lockedBy != -1 || node.lockedDescendants.isEmpty())
            return false;

        for (Node ln : node.lockedDescendants) {
            if (ln.lockedBy != uid) return false;
        }

        List<Node> lockedNodes = new ArrayList<>(node.lockedDescendants);
        for (Node ln : lockedNodes) {
            ln.lockedBy = -1;
            updateAncestorDescendants(ln, -1);
        }

        node.lockedBy = uid;
        updateAncestorDescendants(node, 1);
        return true;
    }

    private void updateAncestorDescendants(Node node, int delta) {
        Node ancestor = node.parent;
        while (ancestor != null) {
            ancestor.lockedDescendantCount += delta;
            if (delta > 0) ancestor.lockedDescendants.add(node);
            else ancestor.lockedDescendants.remove(node);
            ancestor = ancestor.parent;
        }
    }
    
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Read n, m, q
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        int q = Integer.parseInt(br.readLine());
        
        // Read node names
        List<String> nodeNames = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            nodeNames.add(br.readLine());
        }
        
        // Create the locking tree
        LockingTree tree = new LockingTree(n, m, nodeNames);
        
        // Process queries
        for (int i = 0; i < q; i++) {
            String[] query = br.readLine().split(" ");
            int op = Integer.parseInt(query[0]);
            String nodeName = query[1];
            int uid = Integer.parseInt(query[2]);
            
            boolean result = false;
            switch (op) {
                case 1:
                    result = tree.lock(nodeName, uid);
                    break;
                case 2:
                    result = tree.unlock(nodeName, uid);
                    break;
                case 3:
                    result = tree.upgrade(nodeName, uid);
                    break;
            }
            
            System.out.println(result);
        }
        
        br.close();
    }
}

import java.io.*;
import java.util.*;

class Node {
    String name;
    Node parent;
    List<Node> children;
    Integer lockedBy; // null if not locked
    int lockedDescendantCount;
    
    Node(String name) {
        this.name = name;
        this.children = new ArrayList<>();
        this.lockedBy = null;
        this.lockedDescendantCount = 0;
    }
}

public class LockingTree {
    private final Map<String, Node> nodeMap = new HashMap<>();
    
    public LockingTree(int n, int m, List<String> nodeNames) {
        for (String name : nodeNames) {
            nodeMap.put(name, new Node(name));
        }
        
        Node root = nodeMap.get(nodeNames.get(0));
        Queue<Node> queue = new LinkedList<>();
        queue.offer(root);
        
        int index = 1;
        while (!queue.isEmpty() && index < n) {
            Node current = queue.poll();
            for (int i = 0; i < m && index < n; i++) {
                Node child = nodeMap.get(nodeNames.get(index++));
                child.parent = current;
                current.children.add(child);
                queue.offer(child);
            }
        }
    }
    
    public boolean lock(String name, int uid) {
        Node node = nodeMap.get(name);
        if (node.lockedBy != null || node.lockedDescendantCount > 0)
            return false;
        
        Node ancestor = node.parent;
        while (ancestor != null) {
            if (ancestor.lockedBy != null) return false;
            ancestor = ancestor.parent;
        }
        
        node.lockedBy = uid;
        updateAncestorDescendants(node, 1);
        return true;
    }
    
    public boolean unlock(String name, int uid) {
        Node node = nodeMap.get(name);
        if (!uidEquals(node.lockedBy, uid)) return false;
        
        node.lockedBy = null;
        updateAncestorDescendants(node, -1);
        return true;
    }
    
    public boolean upgrade(String name, int uid) {
        Node node = nodeMap.get(name);
        if (node.lockedBy != null || node.lockedDescendantCount == 0)
            return false;
        
        List<Node> lockedNodes = new ArrayList<>();
        if (!collectLockedByUser(node, uid, lockedNodes))
            return false;
        
        for (Node ln : lockedNodes) {
            ln.lockedBy = null;
            updateAncestorDescendants(ln, -1);
        }
        
        node.lockedBy = uid;
        updateAncestorDescendants(node, 1);
        return true;
    }
    
    private void updateAncestorDescendants(Node node, int delta) {
        Node ancestor = node.parent;
        while (ancestor != null) {
            ancestor.lockedDescendantCount += delta;
            ancestor = ancestor.parent;
        }
    }
    
    private boolean collectLockedByUser(Node node, int uid, List<Node> result) {
        if (node.lockedBy != null) {
            if (!uidEquals(node.lockedBy, uid)) return false;
            result.add(node);
        }
        for (Node child : node.children) {
            if (!collectLockedByUser(child, uid, result)) return false;
        }
        return true;
    }
    
    private boolean uidEquals(Integer a, int b) {
        return a != null && a == b;
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Read n, m, q
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        int q = Integer.parseInt(br.readLine());
        
        // Read node names
        List<String> nodeNames = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            nodeNames.add(br.readLine());
        }
        
        // Create the locking tree
        LockingTree tree = new LockingTree(n, m, nodeNames);
        
        // Process queries
        for (int i = 0; i < q; i++) {
            String[] query = br.readLine().split(" ");
            int op = Integer.parseInt(query[0]);
            String nodeName = query[1];
            int uid = Integer.parseInt(query[2]);
            
            boolean result = false;
            switch (op) {
                case 1:
                    result = tree.lock(nodeName, uid);
                    break;
                case 2:
                    result = tree.unlock(nodeName, uid);
                    break;
                case 3:
                    result = tree.upgrade(nodeName, uid);
                    break;
            }
            
            System.out.println(result);
        }
        
        br.close();
    }
}
